{"version":3,"sources":["./node_modules/rxjs/src/internal/observable/forkJoin.ts","/Users/kasaharu/work/packages/forms/src/directives/control_value_accessor.ts","/Users/kasaharu/work/packages/forms/src/directives/default_value_accessor.ts","/Users/kasaharu/work/packages/forms/src/validators.ts","/Users/kasaharu/work/packages/forms/src/directives/abstract_control_directive.ts","/Users/kasaharu/work/packages/forms/src/directives/control_container.ts","/Users/kasaharu/work/packages/forms/src/directives/ng_control.ts","/Users/kasaharu/work/packages/forms/src/directives/ng_control_status.ts","/Users/kasaharu/work/packages/forms/src/directives/shared.ts","/Users/kasaharu/work/packages/forms/src/model.ts","/Users/kasaharu/work/packages/forms/src/directives/ng_no_validate_directive.ts","/Users/kasaharu/work/packages/forms/src/directives/radio_control_value_accessor.ts","/Users/kasaharu/work/packages/forms/src/directives/reactive_directives/form_control_directive.ts","/Users/kasaharu/work/packages/forms/src/directives/reactive_directives/form_group_directive.ts","/Users/kasaharu/work/packages/forms/src/directives/reactive_directives/form_control_name.ts","/Users/kasaharu/work/packages/forms/src/directives.ts","/Users/kasaharu/work/packages/forms/src/form_providers.ts","/Users/kasaharu/work/packages/forms/src/form_builder.ts","./src/app/features/signup/components/signup-form/signup-form.component.html","./src/app/features/signup/components/signup-form/signup-form.component.ts","./src/app/features/signup/containers/signup/signup.component.ts","./src/app/features/signup/containers/signup/signup.component.html","./src/app/features/signup/signup-routing.module.ts","./src/app/features/signup/pages/signup/signup.component.ts","./src/app/features/signup/signup.module.ts"],"names":["forkJoinInternal","sources","keys","Observable","subscriber","len","length","complete","values","Array","completed","emitted","i","source","from","hasValue","add","subscribe","next","value","error","err","reduce","result","key","NG_VALUE_ACCESSOR","DEFAULT_VALUE_ACCESSOR","provide","useExisting","multi","COMPOSITION_BUFFER_MODE","DefaultValueAccessor","_renderer","_elementRef","_compositionMode","onChange","_","onTouched","_composing","this","userAgent","getDOM","getUserAgent","test","toLowerCase","_isAndroid","setProperty","nativeElement","fn","isDisabled","isEmptyInputValue","hasValidLength","NG_VALIDATORS","NG_ASYNC_VALIDATORS","EMAIL_REGEXP","Validators","min","control","parseFloat","isNaN","minValidator","max","maxValidator","requiredValidator","requiredTrueValidator","emailValidator","minLength","minLengthValidator","maxLength","maxLengthValidator","pattern","nullValidator","regex","regexStr","charAt","RegExp","toString","patternValidator","validators","compose","composeAsync","isPresent","o","toObservable","r","obs","isPromise","isObservable","mergeErrors","arrayOfErrors","res","forEach","errors","Object","executeValidators","map","validator","normalizeValidators","validate","isValidatorFn","c","presentValidators","filter","composeValidators","first","isArray","isObject","getPrototypeOf","prototype","resultSelector","pop","pipe","args","forkJoin","composeAsyncValidators","mergeValidators","controlValidators","dirValidator","getControlValidators","_rawValidators","getControlAsyncValidators","_rawAsyncValidators","AbstractControlDirective","_onDestroyCallbacks","valid","invalid","pending","disabled","enabled","pristine","dirty","touched","status","untouched","statusChanges","valueChanges","_composedValidatorFn","_composedAsyncValidatorFn","push","reset","errorCode","path","hasError","getError","ControlContainer","NgControl","_parent","name","valueAccessor","AbstractControlStatus","cd","_cd","NgControlStatus","super","NgControlStatusGroup","setUpControl","dir","setUpValidators","writeValue","registerOnChange","newValue","_pendingValue","_pendingChange","_pendingDirty","updateOn","updateControl","setUpViewChangePipeline","emitModelEvent","viewToModelUpdate","_registerOnDestroy","_unregisterOnChange","setUpModelChangePipeline","registerOnTouched","_pendingTouched","markAsTouched","setUpBlurPipeline","setDisabledState","onDisabledChange","registerOnDisabledChange","_unregisterOnDisabledChange","setUpDisabledChangeHandler","cleanUpControl","validateControlPresenceOnChange","noop","cleanUpValidators","_invokeOnDestroyCallbacks","_registerOnCollectionChange","registerOnValidatorChange","handleOnValidatorChange","setValidators","asyncValidators","asyncValidator","setAsyncValidators","onValidatorChange","updateValueAndValidity","isControlUpdated","updatedValidators","updatedAsyncValidators","markAsDirty","setValue","emitModelToViewChange","removeListItem","list","el","index","indexOf","splice","VALID","INVALID","PENDING","DISABLED","pickValidators","validatorOrOpts","isOptionsObj","coerceToValidator","pickAsyncValidators","coerceToAsyncValidator","_hasOwnPendingAsyncValidator","_onCollectionChange","_onDisabledChange","validatorFn","asyncValidatorFn","_updateOn","parent","newValidator","opts","onlySelf","_forEachChild","markAllAsTouched","markAsUntouched","_updateTouched","markAsPristine","_updatePristine","emitEvent","emit","markAsPending","skipPristineCheck","_parentMarkedDirty","disable","_updateValue","_updateAncestors","changeFn","enable","_setInitialStatus","_cancelExistingSubscription","_runValidator","_calculateStatus","_runAsyncValidator","ctrl","_updateTreeValidity","_allControlsDisabled","_asyncValidationSubscription","setErrors","unsubscribe","_updateControlsErrors","delimiter","split","controlToFind","FormGroup","controls","hasOwnProperty","FormArray","at","_find","get","x","_anyControlsHaveStatus","_anyControls","_anyControlsDirty","_anyControlsTouched","formState","FormControl","_onChange","_applyFormState","_setUpdateStrategy","_initObservables","options","emitViewToModelChange","condition","cb","_isBoxedValue","_setUpControls","setParent","registerControl","controlName","_checkAllValuesPresent","_throwIfControlMissing","patchValue","_reduceChildren","acc","getRawValue","subtreeUpdated","updated","child","_syncPendingControls","Error","_reduceValue","contains","initValue","undefined","_registerControl","some","ɵNgNoValidate","RadioControlRegistryModule","NG_MODEL_WITH_FORM_CONTROL_WARNING","formDirectiveProvider","FormGroupDirective","submitted","_updateDomValue","directives","form","ngSubmit","_setValidators","_setAsyncValidators","changes","_checkFormPresent","_updateValidators","_updateRegistrations","_oldForm","_setUpFormContainer","_cleanUpFormContainer","$event","resetForm","oldCtrl","newCtrl","setUpFormContainer","cleanUpFormContainer","controlNameBinding","FormControlName","valueAccessors","_ngModelWarningConfig","_added","update","_ngModelWarningSent","defaultAccessor","builtinAccessor","customAccessor","v","constructor","selectValueAccessor","_setUpControl","viewModel","change","isFirstChange","is","currentValue","isPropertyUpdated","model","formDirective","updateModel","removeControl","_checkParentType","addControl","_ngModelWarningSentOnce","ɵInternalFormsSharedModule","ReactiveFormsModule","ngModule","providers","useValue","warnOnNgModelWithFormControl","InternalFormsSharedModule","FormBuilder","controlsConfig","_reduceControls","isAbstractControlOptions","_createControl","controlConfig","fullNameValidator","firstName","familyName","emptyFullName","emptyFirstName","emptyFamilyName","passwordConfirmationValidator","password","passwordConfirmation","unmatchPassword","SignupFormComponent","fb","group","required","userName","console","log","onSubmit","SignupComponent","routes","component","SignupPageComponent","pathMatch","SignupRoutingModule","forChild","SignupModule"],"mappings":"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","file":"5.4dd2c82e50b1eef68c9f.js","sourcesContent":["import { Observable } from '../Observable';\nimport { ObservableInput, ObservedValuesFromArray, ObservedValueOf, SubscribableOrPromise } from '../types';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { isObservable } from '../util/isObservable';\nimport { from } from './from';\n\n/* tslint:disable:max-line-length */\n\n// forkJoin(a$, b$, c$)\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(v1: SubscribableOrPromise<T>): Observable<[T]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\n// forkJoin([a$, b$, c$]);\n// TODO(benlesh): Uncomment for TS 3.0\n// export function forkJoin(sources: []): Observable<never>;\nexport function forkJoin<A>(sources: [ObservableInput<A>]): Observable<[A]>;\nexport function forkJoin<A, B>(sources: [ObservableInput<A>, ObservableInput<B>]): Observable<[A, B]>;\nexport function forkJoin<A, B, C>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<[A, B, C]>;\nexport function forkJoin<A, B, C, D>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<[A, B, C, D]>;\nexport function forkJoin<A, B, C, D, E>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<[A, B, C, D, E]>;\nexport function forkJoin<A, B, C, D, E, F>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>, ObservableInput<F>]): Observable<[A, B, C, D, E, F]>;\nexport function forkJoin<A extends ObservableInput<any>[]>(sources: A): Observable<ObservedValuesFromArray<A>[]>;\n\n// forkJoin({})\nexport function forkJoin(sourcesObject: {}): Observable<never>;\nexport function forkJoin<T, K extends keyof T>(sourcesObject: T): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport function forkJoin(...args: Array<ObservableInput<any>|Function>): Observable<any>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed observables to complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first observable,\n * second value is the last thing emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, resulting\n * objects will have the same keys as the dictionary passed, with their last values they've emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input observables, whenever any of\n * that observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input observable errors at some point, `forkJoin` will error as well and all other observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output observable is supposed to emit a result.\n *\n * ## Examples\n *\n * ### Use forkJoin with a dictionary of observable inputs\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000),\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with an array of observable inputs\n * ```ts\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000),\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(\n  ...sources: any[]\n): Observable<any> {\n  if (sources.length === 1) {\n    const first = sources[0];\n    if (isArray(first)) {\n      return forkJoinInternal(first, null);\n    }\n    // TODO(benlesh): isObservable check will not be necessary when deprecated path is removed.\n    if (isObject(first) && Object.getPrototypeOf(first) === Object.prototype) {\n      const keys = Object.keys(first);\n      return forkJoinInternal(keys.map(key => first[key]), keys);\n    }\n  }\n\n  // DEPRECATED PATHS BELOW HERE\n  if (typeof sources[sources.length - 1] === 'function') {\n    const resultSelector = sources.pop() as Function;\n    sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n    return forkJoinInternal(sources, null).pipe(\n      map((args: any[]) => resultSelector(...args))\n    );\n  }\n\n  return forkJoinInternal(sources, null);\n}\n\nfunction forkJoinInternal(sources: ObservableInput<any>[], keys: string[] | null): Observable<any> {\n  return new Observable(subscriber => {\n    const len = sources.length;\n    if (len === 0) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(len);\n    let completed = 0;\n    let emitted = 0;\n    for (let i = 0; i < len; i++) {\n      const source = from(sources[i]);\n      let hasValue = false;\n      subscriber.add(source.subscribe({\n        next: value => {\n          if (!hasValue) {\n            hasValue = true;\n            emitted++;\n          }\n          values[i] = value;\n        },\n        error: err => subscriber.error(err),\n        complete: () => {\n          completed++;\n          if (completed === len || !hasValue) {\n            if (emitted === len) {\n              subscriber.next(keys ?\n                keys.reduce((result, key, i) => (result[key] = values[i], result), {}) :\n                values);\n            }\n            subscriber.complete();\n          }\n        }\n      }));\n    }\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * @description\n * Defines an interface that acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface to create a custom form control directive\n * that integrates with Angular forms.\n *\n * @see DefaultValueAccessor\n *\n * @publicApi\n */\nexport interface ControlValueAccessor {\n  /**\n   * @description\n   * Writes a new value to the element.\n   *\n   * This method is called by the forms API to write to the view when programmatic\n   * changes from model to view are requested.\n   *\n   * @usageNotes\n   * ### Write a value to the element\n   *\n   * The following example writes a value to the native DOM element.\n   *\n   * ```ts\n   * writeValue(value: any): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n   * }\n   * ```\n   *\n   * @param obj The new value for the element\n   */\n  writeValue(obj: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called when the control's value\n   * changes in the UI.\n   *\n   * This method is called by the forms API on initialization to update the form\n   * model when values propagate from the view to the model.\n   *\n   * When implementing the `registerOnChange` method in your own value accessor,\n   * save the given function so your class calls it at the appropriate time.\n   *\n   * @usageNotes\n   * ### Store the change function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnChange(fn: (_: any) => void): void {\n   *   this._onChange = fn;\n   * }\n   * ```\n   *\n   * When the value changes in the UI, call the registered\n   * function to allow the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(change)': '_onChange($event.target.value)'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnChange(fn: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called by the forms API on initialization\n   * to update the form model on blur.\n   *\n   * When implementing `registerOnTouched` in your own value accessor, save the given\n   * function so your class calls it when the control should be considered\n   * blurred or \"touched\".\n   *\n   * @usageNotes\n   * ### Store the callback function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnTouched(fn: any): void {\n   *   this._onTouched = fn;\n   * }\n   * ```\n   *\n   * On blur (or equivalent), your class should call the registered function to allow\n   * the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(blur)': '_onTouched()'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnTouched(fn: any): void;\n\n  /**\n   * @description\n   * Function that is called by the forms API when the control status changes to\n   * or from 'DISABLED'. Depending on the status, it enables or disables the\n   * appropriate DOM element.\n   *\n   * @usageNotes\n   * The following is an example of writing the disabled property to a native DOM element:\n   *\n   * ```ts\n   * setDisabledState(isDisabled: boolean): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n   * }\n   * ```\n   *\n   * @param isDisabled The disabled status to set on the element\n   */\n  setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * Base class for all built-in ControlValueAccessor classes. We use this class to distinguish\n * between built-in and custom CVAs, so that Forms logic can recognize built-in CVAs and treat\n * custom ones with higher priority (when both built-in and custom CVAs are present).\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\nexport class BuiltInControlValueAccessor {}\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n * @publicApi\n */\nexport const NG_VALUE_ACCESSOR =\n    new InjectionToken<ReadonlyArray<ControlValueAccessor>>('NgValueAccessor');","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {Directive, ElementRef, forwardRef, Inject, InjectionToken, Optional, Renderer2} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const DEFAULT_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DefaultValueAccessor),\n  multi: true\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n/**\n * @description\n * Provide this token to control if form directives buffer IME input until\n * the \"compositionend\" event occurs.\n * @publicApi\n */\nexport const COMPOSITION_BUFFER_MODE = new InjectionToken<boolean>('CompositionEventMode');\n\n/**\n * @description\n *\n * {@searchKeywords ngDefaultControl}\n *\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using the default value accessor\n *\n * The following example shows how to use an input element that activates the default value accessor\n * (in this case, a text field).\n *\n * ```ts\n * const firstNameControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"text\" [formControl]=\"firstNameControl\">\n * ```\n *\n * This value accessor is used by default for `<input type=\"text\">` and `<textarea>` elements, but\n * you could also use it for custom components that have similar behavior and do not require special\n * processing. In order to attach the default value accessor to a custom element, add the\n * `ngDefaultControl` attribute as shown below.\n *\n * ```\n * <custom-input-component ngDefaultControl [(ngModel)]=\"value\"></custom-input-component>\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n  // TODO: vsavkin replace the above selector with the one below it once\n  // https://github.com/angular/angular/issues/3011 is implemented\n  // selector: '[ngModel],[formControl],[formControlName]',\n  host: {\n    '(input)': '$any(this)._handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '$any(this)._compositionStart()',\n    '(compositionend)': '$any(this)._compositionEnd($event.target.value)'\n  },\n  providers: [DEFAULT_VALUE_ACCESSOR]\n})\nexport class DefaultValueAccessor implements ControlValueAccessor {\n  /**\n   * The registered callback function called when an input event occurs on the input element.\n   * @nodoc\n   */\n  onChange = (_: any) => {};\n\n  /**\n   * The registered callback function called when a blur event occurs on the input element.\n   * @nodoc\n   */\n  onTouched = () => {};\n\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing = false;\n\n  constructor(\n      private _renderer: Renderer2, private _elementRef: ElementRef,\n      @Optional() @Inject(COMPOSITION_BUFFER_MODE) private _compositionMode: boolean) {\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    const normalizedValue = value == null ? '' : value;\n    this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Registers a function called when the control is touched.\n   * @nodoc\n   */\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the \"disabled\" property on the input element.\n   * @nodoc\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  /** @internal */\n  _handleInput(value: any): void {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this.onChange(value);\n    }\n  }\n\n  /** @internal */\n  _compositionStart(): void {\n    this._composing = true;\n  }\n\n  /** @internal */\n  _compositionEnd(value: any): void {\n    this._composing = false;\n    this._compositionMode && this.onChange(value);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {forkJoin, from, Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {AsyncValidator, AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nimport {AbstractControl} from './model';\n\nfunction isEmptyInputValue(value: any): boolean {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\nfunction hasValidLength(value: any): boolean {\n  // non-strict comparison is intentional, to check for both `null` and `undefined` values\n  return value != null && typeof value.length === 'number';\n}\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_VALIDATORS = new InjectionToken<Array<Validator|Function>>('NgValidators');\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n * @publicApi\n */\nexport const NG_ASYNC_VALIDATORS =\n    new InjectionToken<Array<Validator|Function>>('NgAsyncValidators');\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\nexport class Validators {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```typescript\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static min(min: number): ValidatorFn {\n    return minValidator(min);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```typescript\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static max(max: number): ValidatorFn {\n    return maxValidator(max);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static required(control: AbstractControl): ValidationErrors|null {\n    return requiredValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    return requiredTrueValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * Tests the value using a [regular\n   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n   * pattern suitable for common usecases. The pattern is based on the definition of a valid email\n   * address in the [WHATWG HTML\n   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n   * lengths of different parts of the address).\n   *\n   * The differences from the WHATWG version include:\n   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n   * - Disallow `local-part` to be longer than 64 characters.\n   * - Disallow the whole address to be longer than 254 characters.\n   *\n   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n   * validate the value against a different pattern.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    return emailValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays. The\n   * `minLength` validator logic is also not invoked for values when their `length` property is 0\n   * (for example in case of an empty string or an empty array), to support optional controls. You\n   * can use the standard `required` validator if empty values should not be considered valid.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return minLengthValidator(minLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return maxLengthValidator(maxLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * ### Pattern matching with the global or sticky flag\n   *\n   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n   * can produce different results on the same input when validations are run consecutively. This is\n   * due to how the behavior of `RegExp.prototype.test` is\n   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n   * Due to this behavior, it is recommended that when using\n   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n   * flag enabled.\n   *\n   * ```typescript\n   * // Not recommended (since the `g` flag is used)\n   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n   *\n   * // Good\n   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n   * ```\n   *\n   * @param pattern A regular expression to be used as is to test the values, or a string.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    return patternValidator(pattern);\n  }\n\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return nullValidator(control);\n  }\n\n  /**\n   * @description\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    return compose(validators);\n  }\n\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    return composeAsync(validators);\n  }\n}\n\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport function minValidator(min: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n    return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\nexport function maxValidator(max: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n    return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\nexport function requiredValidator(control: AbstractControl): ValidationErrors|null {\n  return isEmptyInputValue(control.value) ? {'required': true} : null;\n}\n\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\nexport function requiredTrueValidator(control: AbstractControl): ValidationErrors|null {\n  return control.value === true ? null : {'required': true};\n}\n\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\nexport function emailValidator(control: AbstractControl): ValidationErrors|null {\n  if (isEmptyInputValue(control.value)) {\n    return null;  // don't validate empty values to allow optional controls\n  }\n  return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n}\n\n/**\n * Validator that requires the length of the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n */\nexport function minLengthValidator(minLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n      // don't validate empty values to allow optional controls\n      // don't validate values without `length` property\n      return null;\n    }\n\n    return control.value.length < minLength ?\n        {'minlength': {'requiredLength': minLength, 'actualLength': control.value.length}} :\n        null;\n  };\n}\n\n/**\n * Validator that requires the length of the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n */\nexport function maxLengthValidator(maxLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    return hasValidLength(control.value) && control.value.length > maxLength ?\n        {'maxlength': {'requiredLength': maxLength, 'actualLength': control.value.length}} :\n        null;\n  };\n}\n\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\nexport function patternValidator(pattern: string|RegExp): ValidatorFn {\n  if (!pattern) return nullValidator;\n  let regex: RegExp;\n  let regexStr: string;\n  if (typeof pattern === 'string') {\n    regexStr = '';\n\n    if (pattern.charAt(0) !== '^') regexStr += '^';\n\n    regexStr += pattern;\n\n    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value: string = control.value;\n    return regex.test(value) ? null :\n                               {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n  };\n}\n\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\nexport function nullValidator(control: AbstractControl): ValidationErrors|null {\n  return null;\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(r: any): Observable<any> {\n  const obs = isPromise(r) ? from(r) : r;\n  if (!(isObservable(obs)) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n    throw new Error(`Expected validator to return Promise or Observable.`);\n  }\n  return obs;\n}\n\nfunction mergeErrors(arrayOfErrors: (ValidationErrors|null)[]): ValidationErrors|null {\n  let res: {[key: string]: any} = {};\n\n  // Not using Array.reduce here due to a Chrome 80 bug\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n  arrayOfErrors.forEach((errors: ValidationErrors|null) => {\n    res = errors != null ? {...res!, ...errors} : res!;\n  });\n\n  return Object.keys(res).length === 0 ? null : res;\n}\n\ntype GenericValidatorFn = (control: AbstractControl) => any;\n\nfunction executeValidators<V extends GenericValidatorFn>(\n    control: AbstractControl, validators: V[]): ReturnType<V>[] {\n  return validators.map(validator => validator(control));\n}\n\nfunction isValidatorFn<V>(validator: V|Validator|AsyncValidator): validator is V {\n  return !(validator as Validator).validate;\n}\n\n/**\n * Given the list of validators that may contain both functions as well as classes, return the list\n * of validator functions (convert validator classes into validator functions). This is needed to\n * have consistent structure in validators list before composing them.\n *\n * @param validators The set of validators that may contain validators both in plain function form\n *     as well as represented as a validator class.\n */\nexport function normalizeValidators<V>(validators: (V|Validator|AsyncValidator)[]): V[] {\n  return validators.map(validator => {\n    return isValidatorFn<V>(validator) ?\n        validator :\n        ((c: AbstractControl) => validator.validate(c)) as unknown as V;\n  });\n}\n\n/**\n * Merges synchronous validators into a single validator function.\n * See `Validators.compose` for additional information.\n */\nfunction compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n  if (!validators) return null;\n  const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function(control: AbstractControl) {\n    return mergeErrors(executeValidators<ValidatorFn>(control, presentValidators));\n  };\n}\n\n/**\n * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n * validator function.\n */\nexport function composeValidators(validators: Array<Validator|ValidatorFn>): ValidatorFn|null {\n  return validators != null ? compose(normalizeValidators<ValidatorFn>(validators)) : null;\n}\n\n/**\n * Merges asynchronous validators into a single validator function.\n * See `Validators.composeAsync` for additional information.\n */\nfunction composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n  if (!validators) return null;\n  const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function(control: AbstractControl) {\n    const observables =\n        executeValidators<AsyncValidatorFn>(control, presentValidators).map(toObservable);\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\n\n/**\n * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n * them into a single validator function.\n */\nexport function composeAsyncValidators(validators: Array<AsyncValidator|AsyncValidatorFn>):\n    AsyncValidatorFn|null {\n  return validators != null ? composeAsync(normalizeValidators<AsyncValidatorFn>(validators)) :\n                              null;\n}\n\n/**\n * Merges raw control validators with a given directive validator and returns the combined list of\n * validators as an array.\n */\nexport function mergeValidators<V>(controlValidators: V|V[]|null, dirValidator: V): V[] {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] :\n                                            [controlValidators, dirValidator];\n}\n\n/**\n * Retrieves the list of raw synchronous validators attached to a given control.\n */\nexport function getControlValidators(control: AbstractControl): ValidatorFn|ValidatorFn[]|null {\n  return (control as any)._rawValidators as ValidatorFn | ValidatorFn[] | null;\n}\n\n/**\n * Retrieves the list of raw asynchronous validators attached to a given control.\n */\nexport function getControlAsyncValidators(control: AbstractControl): AsyncValidatorFn|\n    AsyncValidatorFn[]|null {\n  return (control as any)._rawAsyncValidators as AsyncValidatorFn | AsyncValidatorFn[] | null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {AbstractControl} from '../model';\nimport {composeAsyncValidators, composeValidators} from '../validators';\n\nimport {AsyncValidator, AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './validators';\n\n\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\nexport abstract class AbstractControlDirective {\n  /**\n   * @description\n   * A reference to the underlying control.\n   *\n   * @returns the control that backs this directive. Most properties fall through to that instance.\n   */\n  abstract get control(): AbstractControl|null;\n\n  /**\n   * @description\n   * Reports the value of the control if it is present, otherwise null.\n   */\n  get value(): any {\n    return this.control ? this.control.value : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is valid. A control is considered valid if no\n   * validation errors exist with the current value.\n   * If the control is not present, null is returned.\n   */\n  get valid(): boolean|null {\n    return this.control ? this.control.valid : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is invalid, meaning that an error exists in the input value.\n   * If the control is not present, null is returned.\n   */\n  get invalid(): boolean|null {\n    return this.control ? this.control.invalid : null;\n  }\n\n  /**\n   * @description\n   * Reports whether a control is pending, meaning that that async validation is occurring and\n   * errors are not yet available for the input value. If the control is not present, null is\n   * returned.\n   */\n  get pending(): boolean|null {\n    return this.control ? this.control.pending : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is disabled, meaning that the control is disabled\n   * in the UI and is exempt from validation checks and excluded from aggregate\n   * values of ancestor controls. If the control is not present, null is returned.\n   */\n  get disabled(): boolean|null {\n    return this.control ? this.control.disabled : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is enabled, meaning that the control is included in ancestor\n   * calculations of validity or value. If the control is not present, null is returned.\n   */\n  get enabled(): boolean|null {\n    return this.control ? this.control.enabled : null;\n  }\n\n  /**\n   * @description\n   * Reports the control's validation errors. If the control is not present, null is returned.\n   */\n  get errors(): ValidationErrors|null {\n    return this.control ? this.control.errors : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is pristine, meaning that the user has not yet changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get pristine(): boolean|null {\n    return this.control ? this.control.pristine : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is dirty, meaning that the user has changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get dirty(): boolean|null {\n    return this.control ? this.control.dirty : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is touched, meaning that the user has triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get touched(): boolean|null {\n    return this.control ? this.control.touched : null;\n  }\n\n  /**\n   * @description\n   * Reports the validation status of the control. Possible values include:\n   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n   * If the control is not present, null is returned.\n   */\n  get status(): string|null {\n    return this.control ? this.control.status : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is untouched, meaning that the user has not yet triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get untouched(): boolean|null {\n    return this.control ? this.control.untouched : null;\n  }\n\n  /**\n   * @description\n   * Returns a multicasting observable that emits a validation status whenever it is\n   * calculated for the control. If the control is not present, null is returned.\n   */\n  get statusChanges(): Observable<any>|null {\n    return this.control ? this.control.statusChanges : null;\n  }\n\n  /**\n   * @description\n   * Returns a multicasting observable of value changes for the control that emits every time the\n   * value of the control changes in the UI or programmatically.\n   * If the control is not present, null is returned.\n   */\n  get valueChanges(): Observable<any>|null {\n    return this.control ? this.control.valueChanges : null;\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path(): string[]|null {\n    return null;\n  }\n\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   */\n  private _composedValidatorFn: ValidatorFn|null|undefined;\n\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   */\n  private _composedAsyncValidatorFn: AsyncValidatorFn|null|undefined;\n\n  /**\n   * Set of synchronous validators as they were provided while calling `setValidators` function.\n   * @internal\n   */\n  _rawValidators: Array<Validator|ValidatorFn> = [];\n\n  /**\n   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`\n   * function.\n   * @internal\n   */\n  _rawAsyncValidators: Array<AsyncValidator|AsyncValidatorFn> = [];\n\n  /**\n   * Sets synchronous validators for this directive.\n   * @internal\n   */\n  _setValidators(validators: Array<Validator|ValidatorFn>|undefined): void {\n    this._rawValidators = validators || [];\n    this._composedValidatorFn = composeValidators(this._rawValidators);\n  }\n\n  /**\n   * Sets asynchronous validators for this directive.\n   * @internal\n   */\n  _setAsyncValidators(validators: Array<AsyncValidator|AsyncValidatorFn>|undefined): void {\n    this._rawAsyncValidators = validators || [];\n    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n  }\n\n  /**\n   * @description\n   * Synchronous validator function composed of all the synchronous validators registered with this\n   * directive.\n   */\n  get validator(): ValidatorFn|null {\n    return this._composedValidatorFn || null;\n  }\n\n  /**\n   * @description\n   * Asynchronous validator function composed of all the asynchronous validators registered with\n   * this directive.\n   */\n  get asyncValidator(): AsyncValidatorFn|null {\n    return this._composedAsyncValidatorFn || null;\n  }\n\n  /*\n   * The set of callbacks to be invoked when directive instance is being destroyed.\n   */\n  private _onDestroyCallbacks: (() => void)[] = [];\n\n  /**\n   * Internal function to register callbacks that should be invoked\n   * when directive instance is being destroyed.\n   * @internal\n   */\n  _registerOnDestroy(fn: () => void): void {\n    this._onDestroyCallbacks.push(fn);\n  }\n\n  /**\n   * Internal function to invoke all registered \"on destroy\" callbacks.\n   * Note: calling this function also clears the list of callbacks.\n   * @internal\n   */\n  _invokeOnDestroyCallbacks(): void {\n    this._onDestroyCallbacks.forEach(fn => fn());\n    this._onDestroyCallbacks = [];\n  }\n\n  /**\n   * @description\n   * Resets the control with the provided value if the control is present.\n   */\n  reset(value: any = undefined): void {\n    if (this.control) this.control.reset(value);\n  }\n\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode: string, path?: Array<string|number>|string): boolean {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode: string, path?: Array<string|number>|string): any {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {Form} from './form_interface';\n\n\n/**\n * @description\n * A base class for directives that contain multiple registered instances of `NgControl`.\n * Only used by the forms module.\n *\n * @publicApi\n */\nexport abstract class ControlContainer extends AbstractControlDirective {\n  /**\n   * @description\n   * The name for the control\n   */\n  // TODO(issue/24571): remove '!'.\n  name!: string|number|null;\n\n  /**\n   * @description\n   * The top-level form directive for the control.\n   */\n  get formDirective(): Form|null {\n    return null;\n  }\n\n  /**\n   * @description\n   * The path to this group.\n   */\n  get path(): string[]|null {\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {ControlValueAccessor} from './control_value_accessor';\n\n\n/**\n * @description\n * A base class that all `FormControl`-based directives extend. It binds a `FormControl`\n * object to a DOM element.\n *\n * @publicApi\n */\nexport abstract class NgControl extends AbstractControlDirective {\n  /**\n   * @description\n   * The parent form for the control.\n   *\n   * @internal\n   */\n  _parent: ControlContainer|null = null;\n\n  /**\n   * @description\n   * The name for the control\n   */\n  name: string|number|null = null;\n\n  /**\n   * @description\n   * The value accessor for the control\n   */\n  valueAccessor: ControlValueAccessor|null = null;\n\n  /**\n   * @description\n   * The callback method to update the model from the view when requested\n   *\n   * @param newValue The new value for the view\n   */\n  abstract viewToModelUpdate(newValue: any): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, Optional, Self} from '@angular/core';\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {NgControl} from './ng_control';\n\ntype AnyControlStatus = 'untouched'|'touched'|'pristine'|'dirty'|'valid'|'invalid'|'pending';\n\nexport class AbstractControlStatus {\n  private _cd: AbstractControlDirective|null;\n\n  constructor(cd: AbstractControlDirective|null) {\n    this._cd = cd;\n  }\n\n  is(status: AnyControlStatus): boolean {\n    return !!this._cd?.control?.[status];\n  }\n}\n\nexport const ngControlStatusHost = {\n  '[class.ng-untouched]': 'is(\"untouched\")',\n  '[class.ng-touched]': 'is(\"touched\")',\n  '[class.ng-pristine]': 'is(\"pristine\")',\n  '[class.ng-dirty]': 'is(\"dirty\")',\n  '[class.ng-valid]': 'is(\"valid\")',\n  '[class.ng-invalid]': 'is(\"invalid\")',\n  '[class.ng-pending]': 'is(\"pending\")',\n};\n\n/**\n * @description\n * Directive automatically applied to Angular form controls that sets CSS classes\n * based on control status.\n *\n * @usageNotes\n *\n * ### CSS classes applied\n *\n * The following classes are applied as the properties become true:\n *\n * * ng-valid\n * * ng-invalid\n * * ng-pending\n * * ng-pristine\n * * ng-dirty\n * * ng-untouched\n * * ng-touched\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost})\nexport class NgControlStatus extends AbstractControlStatus {\n  constructor(@Self() cd: NgControl) {\n    super(cd);\n  }\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form groups that sets CSS classes\n * based on control status (valid/invalid/dirty/etc).\n *\n * @see `NgControlStatus`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',\n  host: ngControlStatusHost\n})\nexport class NgControlStatusGroup extends AbstractControlStatus {\n  constructor(@Optional() @Self() cd: ControlContainer) {\n    super(cd);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControl, FormArray, FormControl, FormGroup} from '../model';\nimport {getControlAsyncValidators, getControlValidators, mergeValidators} from '../validators';\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport {ControlContainer} from './control_container';\nimport {BuiltInControlValueAccessor, ControlValueAccessor} from './control_value_accessor';\nimport {DefaultValueAccessor} from './default_value_accessor';\nimport {NgControl} from './ng_control';\nimport {FormArrayName} from './reactive_directives/form_group_name';\nimport {ReactiveErrors} from './reactive_errors';\nimport {AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\n\nexport function controlPath(name: string|null, parent: ControlContainer): string[] {\n  return [...parent.path!, name!];\n}\n\n/**\n * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n * instances. This function is typically invoked when form directive is being initialized.\n *\n * @param control Form control instance that should be linked.\n * @param dir Directive that should be linked with a given control.\n */\nexport function setUpControl(control: FormControl, dir: NgControl): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!control) _throwError(dir, 'Cannot find control with');\n    if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');\n  }\n\n  setUpValidators(control, dir, /* handleOnValidatorChange */ true);\n\n  dir.valueAccessor!.writeValue(control.value);\n\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n\n  setUpBlurPipeline(control, dir);\n\n  setUpDisabledChangeHandler(control, dir);\n}\n\n/**\n * Reverts configuration performed by the `setUpControl` control function.\n * Effectively disconnects form control with a given form directive.\n * This function is typically invoked when corresponding form directive is being destroyed.\n *\n * @param control Form control which should be cleaned up.\n * @param dir Directive that should be disconnected from a given control.\n * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n */\nexport function cleanUpControl(\n    control: FormControl|null, dir: NgControl,\n    validateControlPresenceOnChange: boolean = true): void {\n  const noop = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      _noControlError(dir);\n    }\n  };\n\n  // The `valueAccessor` field is typically defined on FromControl and FormControlName directive\n  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the\n  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure\n  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from\n  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop);\n    dir.valueAccessor.registerOnTouched(noop);\n  }\n\n  cleanUpValidators(control, dir, /* handleOnValidatorChange */ true);\n\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n    control._registerOnCollectionChange(() => {});\n  }\n}\n\nfunction registerOnValidatorChange<V>(validators: (V|Validator)[], onChange: () => void): void {\n  validators.forEach((validator: (V|Validator)) => {\n    if ((<Validator>validator).registerOnValidatorChange)\n      (<Validator>validator).registerOnValidatorChange!(onChange);\n  });\n}\n\n/**\n * Sets up disabled change handler function on a given form control if ControlValueAccessor\n * associated with a given directive instance supports the `setDisabledState` call.\n *\n * @param control Form control where disabled change handler should be setup.\n * @param dir Corresponding directive instance associated with this control.\n */\nexport function setUpDisabledChangeHandler(control: FormControl, dir: NgControl): void {\n  if (dir.valueAccessor!.setDisabledState) {\n    const onDisabledChange = (isDisabled: boolean) => {\n      dir.valueAccessor!.setDisabledState!(isDisabled);\n    };\n    control.registerOnDisabledChange(onDisabledChange);\n\n    // Register a callback function to cleanup disabled change handler\n    // from a control instance when a directive is destroyed.\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\n\n/**\n * Sets up sync and async directive validators on provided form control.\n * This function merges validators from the directive into the validators of the control.\n *\n * @param control Form control where directive validators should be setup.\n * @param dir Directive instance that contains validators to be setup.\n * @param handleOnValidatorChange Flag that determines whether directive validators should be setup\n *     to handle validator input change.\n */\nexport function setUpValidators(\n    control: AbstractControl, dir: AbstractControlDirective,\n    handleOnValidatorChange: boolean): void {\n  const validators = getControlValidators(control);\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators<ValidatorFn>(validators, dir.validator));\n  } else if (typeof validators === 'function') {\n    // If sync validators are represented by a single validator function, we force the\n    // `Validators.compose` call to happen by executing the `setValidators` function with\n    // an array that contains that function. We need this to avoid possible discrepancies in\n    // validators behavior, so sync validators are always processed by the `Validators.compose`.\n    // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n    // have consistent behavior on AbstractControl API level. The same applies to the async\n    // validators logic below.\n    control.setValidators([validators]);\n  }\n\n  const asyncValidators = getControlAsyncValidators(control);\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(\n        mergeValidators<AsyncValidatorFn>(asyncValidators, dir.asyncValidator));\n  } else if (typeof asyncValidators === 'function') {\n    control.setAsyncValidators([asyncValidators]);\n  }\n\n  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n  if (handleOnValidatorChange) {\n    const onValidatorChange = () => control.updateValueAndValidity();\n    registerOnValidatorChange<ValidatorFn>(dir._rawValidators, onValidatorChange);\n    registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, onValidatorChange);\n  }\n}\n\n/**\n * Cleans up sync and async directive validators on provided form control.\n * This function reverts the setup performed by the `setUpValidators` function, i.e.\n * removes directive-specific validators from a given control instance.\n *\n * @param control Form control from where directive validators should be removed.\n * @param dir Directive instance that contains validators to be removed.\n * @param handleOnValidatorChange Flag that determines whether directive validators should also be\n *     cleaned up to stop handling validator input change (if previously configured to do so).\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpValidators(\n    control: AbstractControl|null, dir: AbstractControlDirective,\n    handleOnValidatorChange: boolean): boolean {\n  let isControlUpdated = false;\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n      if (Array.isArray(validators) && validators.length > 0) {\n        // Filter out directive validator function.\n        const updatedValidators = validators.filter(validator => validator !== dir.validator);\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        // Filter out directive async validator function.\n        const updatedAsyncValidators =\n            asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  }\n\n  if (handleOnValidatorChange) {\n    // Clear onValidatorChange callbacks by providing a noop function.\n    const noop = () => {};\n    registerOnValidatorChange<ValidatorFn>(dir._rawValidators, noop);\n    registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, noop);\n  }\n\n  return isControlUpdated;\n}\n\nfunction setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnChange((newValue: any) => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\n\nfunction setUpBlurPipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnTouched(() => {\n    control._pendingTouched = true;\n\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\n\nfunction updateControl(control: FormControl, dir: NgControl): void {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {emitModelToViewChange: false});\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\n\nfunction setUpModelChangePipeline(control: FormControl, dir: NgControl): void {\n  const onChange = (newValue: any, emitModelEvent: boolean) => {\n    // control -> view\n    dir.valueAccessor!.writeValue(newValue);\n\n    // control -> ngModel\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n  control.registerOnChange(onChange);\n\n  // Register a callback function to cleanup onChange handler\n  // from a control instance when a directive is destroyed.\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\n\n/**\n * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n * present in the view.\n *\n * @param control FormGroup or FormArray instance that should be linked.\n * @param dir Directive that provides view validators.\n */\nexport function setUpFormContainer(\n    control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName) {\n  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwError(dir, 'Cannot find control with');\n  setUpValidators(control, dir, /* handleOnValidatorChange */ false);\n}\n\n/**\n * Reverts the setup performed by the `setUpFormContainer` function.\n *\n * @param control FormGroup or FormArray instance that should be cleaned up.\n * @param dir Directive that provided view validators.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpFormContainer(\n    control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName): boolean {\n  return cleanUpValidators(control, dir, /* handleOnValidatorChange */ false);\n}\n\nfunction _noControlError(dir: NgControl) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\n\nfunction _throwError(dir: AbstractControlDirective, message: string): void {\n  let messageEnd: string;\n  if (dir.path!.length > 1) {\n    messageEnd = `path: '${dir.path!.join(' -> ')}'`;\n  } else if (dir.path![0]) {\n    messageEnd = `name: '${dir.path}'`;\n  } else {\n    messageEnd = 'unspecified name attribute';\n  }\n  throw new Error(`${message} ${messageEnd}`);\n}\n\nexport function isPropertyUpdated(changes: {[key: string]: any}, viewModel: any): boolean {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\n\nexport function isBuiltInAccessor(valueAccessor: ControlValueAccessor): boolean {\n  // Check if a given value accessor is an instance of a class that directly extends\n  // `BuiltInControlValueAccessor` one.\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\n\nexport function syncPendingControls(form: FormGroup, directives: NgControl[]): void {\n  form._syncPendingControls();\n  directives.forEach(dir => {\n    const control = dir.control as FormControl;\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\n\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\nexport function selectValueAccessor(\n    dir: NgControl, valueAccessors: ControlValueAccessor[]): ControlValueAccessor|null {\n  if (!valueAccessors) return null;\n\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwError(dir, 'Value accessor was not provided as an array for form control with');\n\n  let defaultAccessor: ControlValueAccessor|undefined = undefined;\n  let builtinAccessor: ControlValueAccessor|undefined = undefined;\n  let customAccessor: ControlValueAccessor|undefined = undefined;\n\n  valueAccessors.forEach((v: ControlValueAccessor) => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n\n    } else {\n      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _throwError(dir, 'No valid value accessor for form control with');\n  }\n  return null;\n}\n\nexport function removeListItem<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n\n// TODO(kara): remove after deprecation period\nexport function _ngModelWarning(\n    name: string, type: {_ngModelWarningSentOnce: boolean},\n    instance: {_ngModelWarningSent: boolean}, warningConfig: string|null) {\n  if (warningConfig === 'never') return;\n\n  if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||\n      (warningConfig === 'always' && !instance._ngModelWarningSent)) {\n    ReactiveErrors.ngModelWarning(name);\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {removeListItem} from './directives/shared';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from './directives/validators';\nimport {composeAsyncValidators, composeValidators, toObservable} from './validators';\n\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control: AbstractControl, path: Array<string|number>|string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!Array.isArray(path)) {\n    path = path.split(delimiter);\n  }\n  if (Array.isArray(path) && path.length === 0) return null;\n\n  // Not using Array.reduce here due to a Chrome 80 bug\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n  let controlToFind: AbstractControl|null = control;\n  path.forEach((name: string|number) => {\n    if (controlToFind instanceof FormGroup) {\n      controlToFind = controlToFind.controls.hasOwnProperty(name as string) ?\n          controlToFind.controls[name] :\n          null;\n    } else if (controlToFind instanceof FormArray) {\n      controlToFind = controlToFind.at(<number>name) || null;\n    } else {\n      controlToFind = null;\n    }\n  });\n  return controlToFind;\n}\n\n/**\n * Gets validators from either an options object or given validators.\n */\nfunction pickValidators(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|\n                        null): ValidatorFn|ValidatorFn[]|null {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\n\n/**\n * Creates validator function by combining provided validators.\n */\nfunction coerceToValidator(validator: ValidatorFn|ValidatorFn[]|null): ValidatorFn|null {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\n/**\n * Gets async validators from either an options object or given validators.\n */\nfunction pickAsyncValidators(\n    asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null,\n    validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): AsyncValidatorFn|\n    AsyncValidatorFn[]|null {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\n\n/**\n * Creates async validator function by combining provided async validators.\n */\nfunction coerceToAsyncValidator(asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|\n                                null): AsyncValidatorFn|null {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) :\n                                         asyncValidator || null;\n}\n\nexport type FormHooks = 'change'|'blur'|'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport interface AbstractControlOptions {\n  /**\n   * @description\n   * The list of validators applied to a control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * @description\n   * The list of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * @description\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\n\nfunction isOptionsObj(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|\n                      null): validatorOrOpts is AbstractControlOptions {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingDirty!: boolean;\n\n  /**\n   * Indicates that a control has its own pending asynchronous validation in progress.\n   *\n   * @internal\n   */\n  _hasOwnPendingAsyncValidator = false;\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingTouched!: boolean;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _updateOn!: FormHooks;\n\n  private _parent: FormGroup|FormArray|null = null;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   *\n   * @internal\n   */\n  private _composedValidatorFn: ValidatorFn|null;\n\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   *\n   * @internal\n   */\n  private _composedAsyncValidatorFn: AsyncValidatorFn|null;\n\n  /**\n   * Synchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setValidators` function\n   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)\n   *\n   * @internal\n   */\n  private _rawValidators: ValidatorFn|ValidatorFn[]|null;\n\n  /**\n   * Asynchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setAsyncValidators` function\n   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =\n   * asyncValidatorFn`)\n   *\n   * @internal\n   */\n  private _rawAsyncValidators: AsyncValidatorFn|AsyncValidatorFn[]|null;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For an enabled `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a disabled `FormGroup`, the values of all controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value: any;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validators The function or array of functions that is used to determine the validity of\n   *     this control synchronously.\n   * @param asyncValidators The function or array of functions that is used to determine validity of\n   *     this control asynchronously.\n   */\n  constructor(\n      validators: ValidatorFn|ValidatorFn[]|null,\n      asyncValidators: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    this._rawValidators = validators;\n    this._rawAsyncValidators = asyncValidators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n\n  /**\n   * The function that is used to determine the validity of this control synchronously.\n   */\n  get validator(): ValidatorFn|null {\n    return this._composedValidatorFn;\n  }\n  set validator(validatorFn: ValidatorFn|null) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n\n  /**\n   * The function that is used to determine the validity of this control asynchronously.\n   */\n  get asyncValidator(): AsyncValidatorFn|null {\n    return this._composedAsyncValidatorFn;\n  }\n  set asyncValidator(asyncValidatorFn: AsyncValidatorFn|null) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray|null {\n    return this._parent;\n  }\n\n  /**\n   * The validation status of the control. There are four possible\n   * validation status values:\n   *\n   * * **VALID**: This control has passed all validation checks.\n   * * **INVALID**: This control has failed at least one validation check.\n   * * **PENDING**: This control is in the midst of conducting a validation check.\n   * * **DISABLED**: This control is exempt from validation checks.\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly status!: string;\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean {\n    return this.status === VALID;\n  }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean {\n    return this.status === INVALID;\n  }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean {\n    return this.status == PENDING;\n  }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean {\n    return this.status === DISABLED;\n  }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n  get enabled(): boolean {\n    return this.status !== DISABLED;\n  }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly errors!: ValidationErrors|null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  public readonly pristine: boolean = true;\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean {\n    return !this.pristine;\n  }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  public readonly touched: boolean = false;\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean {\n    return !this.touched;\n  }\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically. It also emits an event each time you call enable() or disable()\n   * without passing along {emitEvent: false} as a function argument.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly valueChanges!: Observable<any>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly statusChanges!: Observable<any>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing sync validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  setValidators(newValidator: ValidatorFn|ValidatorFn[]|null): void {\n    this._rawValidators = newValidator;\n    this._composedValidatorFn = coerceToValidator(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this._rawAsyncValidators = newValidator;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(newValidator);\n  }\n\n  /**\n   * Empties out the sync validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearValidators(): void {\n    this.validator = null;\n  }\n\n  /**\n   * Empties out the async validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearAsyncValidators(): void {\n    this.asyncValidator = null;\n  }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value.\n   *\n   * @see `markAsUntouched()`\n   * @see `markAsDirty()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as {touched: boolean}).touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control and all its descendant controls as `touched`.\n   * @see `markAsTouched()`\n   */\n  markAllAsTouched(): void {\n    this.markAsTouched({onlySelf: true});\n\n    this._forEachChild((control: AbstractControl) => control.markAllAsTouched());\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsDirty()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as {touched: boolean}).touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild((control: AbstractControl) => {\n      control.markAsUntouched({onlySelf: true});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's value is changed through the UI; compare `markAsTouched`.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsUntouched()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsDirty(opts: {onlySelf?: boolean} = {}): void {\n    (this as {pristine: boolean}).pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsUntouched()`\n   * @see `markAsDirty()`\n   *\n   * @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsPristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as {pristine: boolean}).pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild((control: AbstractControl) => {\n      control.markAsPristine({onlySelf: true});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as {status: string}).status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      (this.statusChanges as EventEmitter<any>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    (this as {status: string}).status = DISABLED;\n    (this as {errors: ValidationErrors | null}).errors = null;\n    this._forEachChild((control: AbstractControl) => {\n      control.disable({...opts, onlySelf: true});\n    });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    this._updateAncestors({...opts, skipPristineCheck});\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    (this as {status: string}).status = VALID;\n    this._forEachChild((control: AbstractControl) => {\n      control.enable({...opts, onlySelf: true});\n    });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors({...opts, skipPristineCheck});\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(\n      opts: {onlySelf?: boolean, emitEvent?: boolean, skipPristineCheck?: boolean}) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine();\n      }\n      this._parent._updateTouched();\n    }\n  }\n\n  /**\n   * @param parent Sets the parent of the control\n   */\n  setParent(parent: FormGroup|FormArray): void {\n    this._parent = parent;\n  }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: any, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: any, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: any, options?: Object): void;\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      (this as {errors: ValidationErrors | null}).errors = this._runValidator();\n      (this as {status: string}).status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    (this as {status: string}).status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors|null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      (this as {status: string}).status = PENDING;\n      this._hasOwnPendingAsyncValidator = true;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe((errors: ValidationErrors|null) => {\n        this._hasOwnPendingAsyncValidator = false;\n        // This will trigger the recalculation of the validation status, which depends on\n        // the state of the asynchronous validation (whether it is in progress or not). So, it is\n        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n        this.setErrors(errors, {emitEvent});\n      });\n    }\n  }\n\n  private _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n      this._hasOwnPendingAsyncValidator = false;\n    }\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @usageNotes\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {\n    (this as {errors: ValidationErrors | null}).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name']);`\n   *\n   * ### Retrieve a control in a FormArray\n   *\n   * When accessing an element inside a FormArray, you can use an element index.\n   * For example, to get a `price` control from the first element in an `items` array you can use:\n   *\n   * * `this.form.get('items.0.price');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['items', 0, 'price']);`\n   */\n  get(path: Array<string|number>|string): AbstractControl|null {\n    return _find(this, path, '.');\n  }\n\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode: string, path?: Array<string|number>|string): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode: string, path?: Array<string|number>|string): boolean {\n    return !!this.getError(errorCode, path);\n  }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(emitEvent: boolean): void {\n    (this as {status: string}).status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    (this as {valueChanges: Observable<any>}).valueChanges = new EventEmitter();\n    (this as {statusChanges: Observable<any>}).statusChanges = new EventEmitter();\n  }\n\n\n  private _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: Function): void;\n\n  /** @internal */\n  abstract _anyControls(condition: Function): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as {pristine: boolean}).pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as {touched: boolean}).touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n\n  /** @internal */\n  _isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void {\n    this._onCollectionChange = fn;\n  }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn!;\n    }\n  }\n\n  /**\n   * Check to see if parent has been marked artificially dirty.\n   *\n   * @internal\n   */\n  private _parentMarkedDirty(onlySelf?: boolean): boolean {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent!._anyControlsDirty();\n  }\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the three fundamental building blocks of Angular forms, along with\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events. See [usage examples below](#usage-notes).\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n *```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a sync validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to an initial value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n * ```\n *\n * @publicApi\n */\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n\n  /** @internal */\n  _pendingValue: any;\n\n  /** @internal */\n  _pendingChange: any;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param formState Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n      formState: any = null,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this._initObservables();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n      // to `true` to allow that during the control creation process.\n      emitEvent: !!asyncValidator\n    });\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    (this as {value: any}).value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(\n          (changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see `setValue` for options\n   */\n  patchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(formState: any = null, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n\n  /**\n   * @internal\n   */\n  _updateValue() {}\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: Function): boolean {\n    return false;\n  }\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean {\n    return this.disabled;\n  }\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void {\n    this._onChange.push(fn);\n  }\n\n  /**\n   * Internal function to unregister a change events listener.\n   * @internal\n   */\n  _unregisterOnChange(fn: Function): void {\n    removeListItem(this._onChange, fn);\n  }\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n\n  /**\n   * Internal function to unregister a disabled event listener.\n   * @internal\n   */\n  _unregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    removeListItem(this._onDisabledChange, fn);\n  }\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: Function): void {}\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      (this as {value: any}).value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      (this as {value: any}).value = this._pendingValue = formState;\n    }\n  }\n}\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * @publicApi\n */\nexport class FormGroup extends AbstractControl {\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n      public controls: {[key: string]: AbstractControl},\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n      // so we set `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!asyncValidator\n    });\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param controlName The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you exclude a value of a control that does exist.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  patchValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values, so\n    // we just ignore such cases when a field containing FormGroup instance receives `null` or\n    // `undefined` as a value.\n    if (value == null /* both `null` and `undefined` */) return;\n\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param value Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(form.value);  // {last: 'last'}\n   * console.log(form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  reset(value: any = {}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this._updatePristine(options);\n    this._updateTouched(options);\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : (<any>control).getRawValue();\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(key => {\n      // The list of controls can change (for ex. controls might be removed) while the loop\n      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we\n      // have to null check before invoking the callback.\n      const control = this.controls[key];\n      control && cb(control, key);\n    });\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  _updateValue(): void {\n    (this as {value: any}).value = this._reduceValue();\n  }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    for (const controlName of Object.keys(this.controls)) {\n      const control = this.controls[controlName];\n      if (this.contains(controlName) && condition(control)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal */\n  _reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _reduceChildren(initValue: any, fn: Function) {\n    let res = initValue;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport class FormArray extends AbstractControl {\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n      public controls: AbstractControl[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n      // to `true` to allow that during the control creation process.\n      emitEvent: !!asyncValidator\n    });\n  }\n\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number): AbstractControl {\n    return this.controls[index];\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control\n   */\n  removeAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The `AbstractControl` control to replace the existing control\n   */\n  setControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   */\n  get length(): number {\n    return this.controls.length;\n  }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  setValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  patchValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values, so\n    // we just ignore such cases when a field containing FormArray instance receives `null` or\n    // `undefined` as a value.\n    if (value == null /* both `null` and `undefined` */) return;\n\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * this.arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * console.log(this.arr.get(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  reset(value: any = [], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this._updatePristine(options);\n    this._updateTouched(options);\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : (<any>control).getRawValue();\n    });\n  }\n\n  /**\n   * Remove all controls in the `FormArray`.\n   *\n   * @usageNotes\n   * ### Remove all elements from a FormArray\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.length);  // 2\n   *\n   * arr.clear();\n   * console.log(arr.length);  // 0\n   * ```\n   *\n   * It's a simpler and more efficient alternative to removing all elements one by one:\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   *\n   * while (arr.length) {\n   *    arr.removeAt(0);\n   * }\n   * ```\n   */\n  clear(): void {\n    if (this.controls.length < 1) return;\n    this._forEachChild((control: AbstractControl) => control._registerOnCollectionChange(() => {}));\n    this.controls.splice(0);\n    this.updateValueAndValidity();\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this.controls.reduce((updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => {\n      cb(control, index);\n    });\n  }\n\n  /** @internal */\n  _updateValue(): void {\n    (this as {value: any}).value =\n        this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n  }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  private _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive} from '@angular/core';\n\n/**\n * @description\n *\n * Adds `novalidate` attribute to all forms by default.\n *\n * `novalidate` is used to disable browser's native form validation.\n *\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\n *\n * ```\n * <form ngNativeValidate></form>\n * ```\n *\n * @publicApi\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n */\n@Directive({\n  selector: 'form:not([ngNoForm]):not([ngNativeValidate])',\n  host: {'novalidate': ''},\n})\nexport class ɵNgNoValidate {\n}\n\nexport {ɵNgNoValidate as NgNoValidate};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, Injectable, Injector, Input, NgModule, OnDestroy, OnInit, Renderer2} from '@angular/core';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\nimport {NgControl} from './ng_control';\n\nexport const RADIO_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RadioControlValueAccessor),\n  multi: true\n};\n\nfunction throwNameError() {\n  throw new Error(`\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    `);\n}\n\n/**\n * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable\n * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's\n * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support\n * `forwardRef` logic.\n */\n@NgModule()\nexport class RadioControlRegistryModule {\n}\n\n/**\n * @description\n * Class used by Angular to track radio buttons. For internal use only.\n */\n@Injectable({providedIn: RadioControlRegistryModule})\nexport class RadioControlRegistry {\n  private _accessors: any[] = [];\n\n  /**\n   * @description\n   * Adds a control to the internal registry. For internal use only.\n   */\n  add(control: NgControl, accessor: RadioControlValueAccessor) {\n    this._accessors.push([control, accessor]);\n  }\n\n  /**\n   * @description\n   * Removes a control from the internal registry. For internal use only.\n   */\n  remove(accessor: RadioControlValueAccessor) {\n    for (let i = this._accessors.length - 1; i >= 0; --i) {\n      if (this._accessors[i][1] === accessor) {\n        this._accessors.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  /**\n   * @description\n   * Selects a radio button. For internal use only.\n   */\n  select(accessor: RadioControlValueAccessor) {\n    this._accessors.forEach((c) => {\n      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {\n        c[1].fireUncheck(accessor.value);\n      }\n    });\n  }\n\n  private _isSameGroup(\n      controlPair: [NgControl, RadioControlValueAccessor],\n      accessor: RadioControlValueAccessor): boolean {\n    if (!controlPair[0].control) return false;\n    return controlPair[0]._parent === accessor._control._parent &&\n        controlPair[1].name === accessor.name;\n  }\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using radio buttons with reactive form directives\n *\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\n * Providing a `name` attribute is optional.\n *\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n  host: {'(change)': 'onChange()', '(blur)': 'onTouched()'},\n  providers: [RADIO_VALUE_ACCESSOR]\n})\nexport class RadioControlValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor, OnDestroy, OnInit {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _state!: boolean;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _control!: NgControl;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _fn!: Function;\n\n  /**\n   * The registered callback function called when a change event occurs on the input element.\n   * @nodoc\n   */\n  onChange = () => {};\n\n  /**\n   * The registered callback function called when a blur event occurs on the input element.\n   * @nodoc\n   */\n  onTouched = () => {};\n\n  /**\n   * @description\n   * Tracks the name of the radio input element.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input() name!: string;\n\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input() formControlName!: string;\n\n  /**\n   * @description\n   * Tracks the value of the radio input element\n   */\n  @Input() value: any;\n\n  constructor(\n      private _renderer: Renderer2, private _elementRef: ElementRef,\n      private _registry: RadioControlRegistry, private _injector: Injector) {\n    super();\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this._control = this._injector.get(NgControl);\n    this._checkName();\n    this._registry.add(this._control, this);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this._registry.remove(this);\n  }\n\n  /**\n   * Sets the \"checked\" property value on the radio input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this._state = value === this.value;\n    this._renderer.setProperty(this._elementRef.nativeElement, 'checked', this._state);\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn: (_: any) => {}): void {\n    this._fn = fn;\n    this.onChange = () => {\n      fn(this.value);\n      this._registry.select(this);\n    };\n  }\n\n  /**\n   * Sets the \"value\" on the radio input element and unchecks it.\n   *\n   * @param value\n   */\n  fireUncheck(value: any): void {\n    this.writeValue(value);\n  }\n\n  /**\n   * Registers a function called when the control is touched.\n   * @nodoc\n   */\n  registerOnTouched(fn: () => {}): void {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the \"disabled\" property on the input element.\n   * @nodoc\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  private _checkName(): void {\n    if (this.name && this.formControlName && this.name !== this.formControlName &&\n        (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwNameError();\n    }\n    if (!this.name && this.formControlName) this.name = this.formControlName;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Inject, InjectionToken, Input, OnChanges, OnDestroy, Optional, Output, Self, SimpleChanges} from '@angular/core';\n\nimport {FormControl} from '../../model';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';\nimport {NgControl} from '../ng_control';\nimport {ReactiveErrors} from '../reactive_errors';\nimport {_ngModelWarning, cleanUpControl, isPropertyUpdated, selectValueAccessor, setUpControl} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\n\n/**\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\n */\nexport const NG_MODEL_WITH_FORM_CONTROL_WARNING =\n    new InjectionToken('NgModelWithFormControlWarning');\n\nexport const formControlBinding: any = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlDirective)\n};\n\n/**\n * @description\n * Synchronizes a standalone `FormControl` instance to a form control element.\n *\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives was deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * The following example shows how to register a standalone control and set its value.\n *\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm'})\nexport class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n  /**\n   * Internal reference to the view model value.\n   * @nodoc\n   */\n  viewModel: any;\n\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('formControl') form!: FormControl;\n\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  @Input('disabled')\n  set isDisabled(isDisabled: boolean) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      ReactiveErrors.disabledAttrWarning();\n    }\n  }\n\n  // TODO(kara): remove next 4 properties once deprecation period is over\n\n  /** @deprecated as of v6 */\n  @Input('ngModel') model: any;\n\n  /** @deprecated as of v6 */\n  @Output('ngModelChange') update = new EventEmitter();\n\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlDirective. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular `FormControlDirective` instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n\n  constructor(\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\n      @Optional() @Inject(NG_MODEL_WITH_FORM_CONTROL_WARNING) private _ngModelWarningConfig: string|\n      null) {\n    super();\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._isControlChanged(changes)) {\n      const previousForm = changes['form'].previousValue;\n      if (previousForm) {\n        cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);\n      }\n      setUpControl(this.form, this);\n      if (this.control.disabled && this.valueAccessor!.setDisabledState) {\n        this.valueAccessor!.setDisabledState!(true);\n      }\n      this.form.updateValueAndValidity({emitEvent: false});\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);\n      }\n      this.form.setValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);\n    }\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path(): string[] {\n    return [];\n  }\n\n  /**\n   * @description\n   * The `FormControl` bound to this directive.\n   */\n  get control(): FormControl {\n    return this.form;\n  }\n\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  viewToModelUpdate(newValue: any): void {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n\n  private _isControlChanged(changes: {[key: string]: any}): boolean {\n    return changes.hasOwnProperty('form');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Inject, Input, OnChanges, OnDestroy, Optional, Output, Self, SimpleChanges} from '@angular/core';\n\nimport {FormArray, FormControl, FormGroup} from '../../model';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {ControlContainer} from '../control_container';\nimport {Form} from '../form_interface';\nimport {ReactiveErrors} from '../reactive_errors';\nimport {cleanUpControl, cleanUpFormContainer, cleanUpValidators, removeListItem, setUpControl, setUpFormContainer, setUpValidators, syncPendingControls} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\nimport {FormControlName} from './form_control_name';\nimport {FormArrayName, FormGroupName} from './form_group_name';\n\nexport const formDirectiveProvider: any = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupDirective)\n};\n\n/**\n * @description\n *\n * Binds an existing `FormGroup` to a DOM element.\n *\n * This directive accepts an existing `FormGroup` instance. It will then use this\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`,\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\n * and `FormArrayName` directives.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `AbstractControl`\n *\n * @usageNotes\n * ### Register Form Group\n *\n * The following example registers a `FormGroup` with first name and last name controls,\n * and listens for the *ngSubmit* event when the button is clicked.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[formGroup]',\n  providers: [formDirectiveProvider],\n  host: {'(submit)': 'onSubmit($event)', '(reset)': 'onReset()'},\n  exportAs: 'ngForm'\n})\nexport class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n  /**\n   * @description\n   * Reports whether the form submission has been triggered.\n   */\n  public readonly submitted: boolean = false;\n\n  /**\n   * Reference to an old form group input value, which is needed to cleanup old instance in case it\n   * was replaced with a new one.\n   */\n  private _oldForm: FormGroup|undefined;\n\n  /**\n   * Callback that should be invoked when controls in FormGroup or FormArray collection change\n   * (added or removed). This callback triggers corresponding DOM updates.\n   */\n  private readonly _onCollectionChange = () => this._updateDomValue();\n\n  /**\n   * @description\n   * Tracks the list of added `FormControlName` instances\n   */\n  directives: FormControlName[] = [];\n\n  /**\n   * @description\n   * Tracks the `FormGroup` bound to this directive.\n   */\n  @Input('formGroup') form: FormGroup = null!;\n\n  /**\n   * @description\n   * Emits an event when the form submission has been triggered.\n   */\n  @Output() ngSubmit = new EventEmitter();\n\n  constructor(\n      @Optional() @Self() @Inject(NG_VALIDATORS) private validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) private asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[]) {\n    super();\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    this._checkFormPresent();\n    if (changes.hasOwnProperty('form')) {\n      this._updateValidators();\n      this._updateDomValue();\n      this._updateRegistrations();\n      this._oldForm = this.form;\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpValidators(this.form, this, /* handleOnValidatorChange */ false);\n\n      // Currently the `onCollectionChange` callback is rewritten each time the\n      // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should\n      // happen *only* when the `onCollectionChange` callback was set by this directive instance.\n      // Otherwise it might cause overriding a callback of some other directive instances. We should\n      // consider updating this logic later to make it similar to how `onChange` callbacks are\n      // handled, see https://github.com/angular/angular/issues/39732 for additional info.\n      if (this.form._onCollectionChange === this._onCollectionChange) {\n        this.form._registerOnCollectionChange(() => {});\n      }\n    }\n  }\n\n  /**\n   * @description\n   * Returns this directive's instance.\n   */\n  get formDirective(): Form {\n    return this;\n  }\n\n  /**\n   * @description\n   * Returns the `FormGroup` bound to this directive.\n   */\n  get control(): FormGroup {\n    return this.form;\n  }\n\n  /**\n   * @description\n   * Returns an array representing the path to this group. Because this directive\n   * always lives at the top level of a form, it always an empty array.\n   */\n  get path(): string[] {\n    return [];\n  }\n\n  /**\n   * @description\n   * Method that sets up the control directive in this group, re-calculates its value\n   * and validity, and adds the instance to the internal list of directives.\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  addControl(dir: FormControlName): FormControl {\n    const ctrl: any = this.form.get(dir.path);\n    setUpControl(ctrl, dir);\n    ctrl.updateValueAndValidity({emitEvent: false});\n    this.directives.push(dir);\n    return ctrl;\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormControl` instance from the provided `FormControlName` directive\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  getControl(dir: FormControlName): FormControl {\n    return <FormControl>this.form.get(dir.path);\n  }\n\n  /**\n   * @description\n   * Removes the `FormControlName` instance from the internal list of directives\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  removeControl(dir: FormControlName): void {\n    cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */ false);\n    removeListItem(this.directives, dir);\n  }\n\n  /**\n   * Adds a new `FormGroupName` directive instance to the form.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  addFormGroup(dir: FormGroupName): void {\n    this._setUpFormContainer(dir);\n  }\n\n  /**\n   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  removeFormGroup(dir: FormGroupName): void {\n    this._cleanUpFormContainer(dir);\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  getFormGroup(dir: FormGroupName): FormGroup {\n    return <FormGroup>this.form.get(dir.path);\n  }\n\n  /**\n   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  addFormArray(dir: FormArrayName): void {\n    this._setUpFormContainer(dir);\n  }\n\n  /**\n   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  removeFormArray(dir: FormArrayName): void {\n    this._cleanUpFormContainer(dir);\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  getFormArray(dir: FormArrayName): FormArray {\n    return <FormArray>this.form.get(dir.path);\n  }\n\n  /**\n   * Sets the new value for the provided `FormControlName` directive.\n   *\n   * @param dir The `FormControlName` directive instance.\n   * @param value The new value for the directive's control.\n   */\n  updateModel(dir: FormControlName, value: any): void {\n    const ctrl  = <FormControl>this.form.get(dir.path);\n    ctrl.setValue(value);\n  }\n\n  /**\n   * @description\n   * Method called with the \"submit\" event is triggered on the form.\n   * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n   *\n   * @param $event The \"submit\" event object\n   */\n  onSubmit($event: Event): boolean {\n    (this as {submitted: boolean}).submitted = true;\n    syncPendingControls(this.form, this.directives);\n    this.ngSubmit.emit($event);\n    return false;\n  }\n\n  /**\n   * @description\n   * Method called when the \"reset\" event is triggered on the form.\n   */\n  onReset(): void {\n    this.resetForm();\n  }\n\n  /**\n   * @description\n   * Resets the form to an initial value and resets its submitted status.\n   *\n   * @param value The new value for the form.\n   */\n  resetForm(value: any = undefined): void {\n    this.form.reset(value);\n    (this as {submitted: boolean}).submitted = false;\n  }\n\n\n  /** @internal */\n  _updateDomValue() {\n    this.directives.forEach(dir => {\n      const oldCtrl = dir.control;\n      const newCtrl = this.form.get(dir.path);\n      if (oldCtrl !== newCtrl) {\n        // Note: the value of the `dir.control` may not be defined, for example when it's a first\n        // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).\n        cleanUpControl(oldCtrl || null, dir);\n\n        // Check whether new control at the same location inside the corresponding `FormGroup` is an\n        // instance of `FormControl` and perform control setup only if that's the case.\n        // Note: we don't need to clear the list of directives (`this.directives`) here, it would be\n        // taken care of in the `removeControl` method invoked when corresponding `formControlName`\n        // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).\n        if (newCtrl instanceof FormControl) {\n          setUpControl(newCtrl, dir);\n          (dir as {control: FormControl}).control = newCtrl;\n        }\n      }\n    });\n\n    this.form._updateTreeValidity({emitEvent: false});\n  }\n\n  private _setUpFormContainer(dir: FormArrayName|FormGroupName): void {\n    const ctrl: any = this.form.get(dir.path);\n    setUpFormContainer(ctrl, dir);\n    // NOTE: this operation looks unnecessary in case no new validators were added in\n    // `setUpFormContainer` call. Consider updating this code to match the logic in\n    // `_cleanUpFormContainer` function.\n    ctrl.updateValueAndValidity({emitEvent: false});\n  }\n\n  private _cleanUpFormContainer(dir: FormArrayName|FormGroupName): void {\n    if (this.form) {\n      const ctrl: any = this.form.get(dir.path);\n      if (ctrl) {\n        const isControlUpdated = cleanUpFormContainer(ctrl, dir);\n        if (isControlUpdated) {\n          // Run validity check only in case a control was updated (i.e. view validators were\n          // removed) as removing view validators might cause validity to change.\n          ctrl.updateValueAndValidity({emitEvent: false});\n        }\n      }\n    }\n  }\n\n  private _updateRegistrations() {\n    this.form._registerOnCollectionChange(this._onCollectionChange);\n    if (this._oldForm) {\n      this._oldForm._registerOnCollectionChange(() => {});\n    }\n  }\n\n  private _updateValidators() {\n    setUpValidators(this.form, this, /* handleOnValidatorChange */ false);\n    if (this._oldForm) {\n      cleanUpValidators(this._oldForm, this, /* handleOnValidatorChange */ false);\n    }\n  }\n\n  private _checkFormPresent() {\n    if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      ReactiveErrors.missingFormException();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Host, Inject, Input, OnChanges, OnDestroy, Optional, Output, Self, SimpleChanges, SkipSelf} from '@angular/core';\n\nimport {FormControl} from '../../model';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {AbstractFormGroupDirective} from '../abstract_form_group_directive';\nimport {ControlContainer} from '../control_container';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';\nimport {NgControl} from '../ng_control';\nimport {ReactiveErrors} from '../reactive_errors';\nimport {_ngModelWarning, controlPath, isPropertyUpdated, selectValueAccessor} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\nimport {NG_MODEL_WITH_FORM_CONTROL_WARNING} from './form_control_directive';\nimport {FormGroupDirective} from './form_group_directive';\nimport {FormArrayName, FormGroupName} from './form_group_name';\n\nexport const controlNameBinding: any = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlName)\n};\n\n/**\n * @description\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\n * element by name.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * ### Register `FormControl` within a group\n *\n * The following example shows how to register multiple form controls within a form group\n * and set their value.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * To see `formControlName` examples with different form control types, see:\n *\n * * Radio buttons: `RadioControlValueAccessor`\n * * Selects: `SelectControlValueAccessor`\n *\n * ### Use with ngModel is deprecated\n *\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n *\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formControlName]', providers: [controlNameBinding]})\nexport class FormControlName extends NgControl implements OnChanges, OnDestroy {\n  private _added = false;\n  /**\n   * Internal reference to the view model value.\n   * @internal\n   */\n  viewModel: any;\n\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly control!: FormControl;\n\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form controls to be bound\n   * to indices when iterating over controls in a `FormArray`.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('formControlName') name!: string|number|null;\n\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  @Input('disabled')\n  set isDisabled(isDisabled: boolean) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      ReactiveErrors.disabledAttrWarning();\n    }\n  }\n\n  // TODO(kara): remove next 4 properties once deprecation period is over\n\n  /** @deprecated as of v6 */\n  @Input('ngModel') model: any;\n\n  /** @deprecated as of v6 */\n  @Output('ngModelChange') update = new EventEmitter();\n\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlName. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular FormControlName instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n\n  constructor(\n      @Optional() @Host() @SkipSelf() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\n      @Optional() @Inject(NG_MODEL_WITH_FORM_CONTROL_WARNING) private _ngModelWarningConfig: string|\n      null) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (!this._added) this._setUpControl();\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);\n      }\n      this.viewModel = this.model;\n      this.formDirective.updateModel(this, this.model);\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this.formDirective) {\n      this.formDirective.removeControl(this);\n    }\n  }\n\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  viewToModelUpdate(newValue: any): void {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path(): string[] {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent!);\n  }\n\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  get formDirective(): any {\n    return this._parent ? this._parent.formDirective : null;\n  }\n\n  private _checkParentType(): void {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!(this._parent instanceof FormGroupName) &&\n          this._parent instanceof AbstractFormGroupDirective) {\n        ReactiveErrors.ngModelGroupException();\n      } else if (\n          !(this._parent instanceof FormGroupName) &&\n          !(this._parent instanceof FormGroupDirective) &&\n          !(this._parent instanceof FormArrayName)) {\n        ReactiveErrors.controlParentException();\n      }\n    }\n  }\n\n  private _setUpControl() {\n    this._checkParentType();\n    (this as {control: FormControl}).control = this.formDirective.addControl(this);\n    if (this.control.disabled && this.valueAccessor!.setDisabledState) {\n      this.valueAccessor!.setDisabledState!(true);\n    }\n    this._added = true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule, Type} from '@angular/core';\n\nimport {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\nimport {DefaultValueAccessor} from './directives/default_value_accessor';\nimport {NgControlStatus, NgControlStatusGroup} from './directives/ng_control_status';\nimport {NgForm} from './directives/ng_form';\nimport {NgModel} from './directives/ng_model';\nimport {NgModelGroup} from './directives/ng_model_group';\nimport {NgNoValidate} from './directives/ng_no_validate_directive';\nimport {NumberValueAccessor} from './directives/number_value_accessor';\nimport {RadioControlRegistryModule, RadioControlValueAccessor} from './directives/radio_control_value_accessor';\nimport {RangeValueAccessor} from './directives/range_value_accessor';\nimport {FormControlDirective} from './directives/reactive_directives/form_control_directive';\nimport {FormControlName} from './directives/reactive_directives/form_control_name';\nimport {FormGroupDirective} from './directives/reactive_directives/form_group_directive';\nimport {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\nimport {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\nimport {NgSelectMultipleOption, SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\nimport {CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MinLengthValidator, PatternValidator, RequiredValidator} from './directives/validators';\n\nexport {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\nexport {ControlValueAccessor} from './directives/control_value_accessor';\nexport {DefaultValueAccessor} from './directives/default_value_accessor';\nexport {NgControl} from './directives/ng_control';\nexport {NgControlStatus, NgControlStatusGroup} from './directives/ng_control_status';\nexport {NgForm} from './directives/ng_form';\nexport {NgModel} from './directives/ng_model';\nexport {NgModelGroup} from './directives/ng_model_group';\nexport {NumberValueAccessor} from './directives/number_value_accessor';\nexport {RadioControlValueAccessor} from './directives/radio_control_value_accessor';\nexport {RangeValueAccessor} from './directives/range_value_accessor';\nexport {FormControlDirective, NG_MODEL_WITH_FORM_CONTROL_WARNING} from './directives/reactive_directives/form_control_directive';\nexport {FormControlName} from './directives/reactive_directives/form_control_name';\nexport {FormGroupDirective} from './directives/reactive_directives/form_group_directive';\nexport {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\nexport {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\nexport {NgSelectMultipleOption, SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\n\nexport const SHARED_FORM_DIRECTIVES: Type<any>[] = [\n  NgNoValidate,\n  NgSelectOption,\n  NgSelectMultipleOption,\n  DefaultValueAccessor,\n  NumberValueAccessor,\n  RangeValueAccessor,\n  CheckboxControlValueAccessor,\n  SelectControlValueAccessor,\n  SelectMultipleControlValueAccessor,\n  RadioControlValueAccessor,\n  NgControlStatus,\n  NgControlStatusGroup,\n  RequiredValidator,\n  MinLengthValidator,\n  MaxLengthValidator,\n  PatternValidator,\n  CheckboxRequiredValidator,\n  EmailValidator,\n];\n\nexport const TEMPLATE_DRIVEN_DIRECTIVES: Type<any>[] = [NgModel, NgModelGroup, NgForm];\n\nexport const REACTIVE_DRIVEN_DIRECTIVES: Type<any>[] =\n    [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];\n\n/**\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n */\n@NgModule({\n  declarations: SHARED_FORM_DIRECTIVES,\n  imports: [RadioControlRegistryModule],\n  exports: SHARED_FORM_DIRECTIVES,\n})\nexport class ɵInternalFormsSharedModule {\n}\n\nexport {ɵInternalFormsSharedModule as InternalFormsSharedModule};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {InternalFormsSharedModule, NG_MODEL_WITH_FORM_CONTROL_WARNING, REACTIVE_DRIVEN_DIRECTIVES, TEMPLATE_DRIVEN_DIRECTIVES} from './directives';\n\n/**\n * Exports the required providers and directives for template-driven forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](/guide/forms-overview)\n * @see [Template-driven Forms Guide](/guide/forms)\n *\n * @publicApi\n */\n@NgModule({\n  declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n  exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n})\nexport class FormsModule {\n}\n\n/**\n * Exports the required infrastructure and directives for reactive forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `FormBuilder`\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](guide/forms-overview)\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\n@NgModule({\n  declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n  exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n})\nexport class ReactiveFormsModule {\n  /**\n   * @description\n   * Provides options for configuring the reactive forms module.\n   *\n   * @param opts An object of configuration options\n   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\n   * binding is used with reactive form directives.\n   */\n  static withConfig(opts: {\n    /** @deprecated as of v6 */ warnOnNgModelWithFormControl: 'never'|'once'|'always'\n  }): ModuleWithProviders<ReactiveFormsModule> {\n    return {\n      ngModule: ReactiveFormsModule,\n      providers: [\n        {provide: NG_MODEL_WITH_FORM_CONTROL_WARNING, useValue: opts.warnOnNgModelWithFormControl}\n      ]\n    };\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {ReactiveFormsModule} from './form_providers';\nimport {AbstractControl, AbstractControlOptions, FormArray, FormControl, FormGroup, FormHooks} from './model';\n\nfunction isAbstractControlOptions(options: AbstractControlOptions|\n                                  {[key: string]: any}): options is AbstractControlOptions {\n  return (<AbstractControlOptions>options).asyncValidators !== undefined ||\n      (<AbstractControlOptions>options).validators !== undefined ||\n      (<AbstractControlOptions>options).updateOn !== undefined;\n}\n\n/**\n * @description\n * Creates an `AbstractControl` from a user-specified configuration.\n *\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,\n * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex\n * forms.\n *\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n *\n * @publicApi\n */\n@Injectable({providedIn: ReactiveFormsModule})\nexport class FormBuilder {\n  /**\n   * @description\n   * Construct a new `FormGroup` instance.\n   *\n   * @param controlsConfig A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The object should have the\n   * the `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions\n   * * `asyncValidators`: A single async validator or array of async validator functions\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n   * submit')\n   */\n  group(\n      controlsConfig: {[key: string]: any},\n      options?: AbstractControlOptions|null,\n      ): FormGroup;\n  /**\n   * @description\n   * Construct a new `FormGroup` instance.\n   *\n   * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n   * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n   * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\n   * validators. If you have custom validators, make sure their validation function parameter is\n   * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called with\n   * an object of type `AbstractControl` and that cannot be automatically downcast to a subclass, so\n   * TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\n   * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\n   *\n   * @param controlsConfig A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The legacy configuration\n   * object consists of:\n   * * `validator`: A synchronous validator function, or an array of validator functions\n   * * `asyncValidator`: A single async validator or array of async validator functions\n   * Note: the legacy format is deprecated and might be removed in one of the next major versions\n   * of Angular.\n   */\n  group(\n      controlsConfig: {[key: string]: any},\n      options: {[key: string]: any},\n      ): FormGroup;\n  group(\n      controlsConfig: {[key: string]: any},\n      options: AbstractControlOptions|{[key: string]: any}|null = null): FormGroup {\n    const controls = this._reduceControls(controlsConfig);\n\n    let validators: ValidatorFn|ValidatorFn[]|null = null;\n    let asyncValidators: AsyncValidatorFn|AsyncValidatorFn[]|null = null;\n    let updateOn: FormHooks|undefined = undefined;\n\n    if (options != null) {\n      if (isAbstractControlOptions(options)) {\n        // `options` are `AbstractControlOptions`\n        validators = options.validators != null ? options.validators : null;\n        asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;\n        updateOn = options.updateOn != null ? options.updateOn : undefined;\n      } else {\n        // `options` are legacy form group options\n        validators = options['validator'] != null ? options['validator'] : null;\n        asyncValidators = options['asyncValidator'] != null ? options['asyncValidator'] : null;\n      }\n    }\n\n    return new FormGroup(controls, {asyncValidators, updateOn, validators});\n  }\n\n  /**\n   * @description\n   * Construct a new `FormControl` with the given state, validators and options.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * @usageNotes\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n   *\n   * <code-example path=\"forms/ts/formBuilder/form_builder_example.ts\" region=\"disabled-control\">\n   * </code-example>\n   */\n  control(\n      formState: any, validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl {\n    return new FormControl(formState, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options.\n   *\n   * @param controlsConfig An array of child controls or control configs. Each\n   * child control is given an index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   */\n  array(\n      controlsConfig: any[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormArray {\n    const controls = controlsConfig.map(c => this._createControl(c));\n    return new FormArray(controls, validatorOrOpts, asyncValidator);\n  }\n\n  /** @internal */\n  _reduceControls(controlsConfig: {[k: string]: any}): {[key: string]: AbstractControl} {\n    const controls: {[key: string]: AbstractControl} = {};\n    Object.keys(controlsConfig).forEach(controlName => {\n      controls[controlName] = this._createControl(controlsConfig[controlName]);\n    });\n    return controls;\n  }\n\n  /** @internal */\n  _createControl(controlConfig: any): AbstractControl {\n    if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||\n        controlConfig instanceof FormArray) {\n      return controlConfig;\n\n    } else if (Array.isArray(controlConfig)) {\n      const value = controlConfig[0];\n      const validator: ValidatorFn = controlConfig.length > 1 ? controlConfig[1] : null;\n      const asyncValidator: AsyncValidatorFn = controlConfig.length > 2 ? controlConfig[2] : null;\n      return this.control(value, validator, asyncValidator);\n\n    } else {\n      return this.control(controlConfig);\n    }\n  }\n}\n","<div class=\"title\">\n  <span>ダミーアカウントの作成</span>\n</div>\n\n<div class=\"contents\">\n  <form [formGroup]=\"form\">\n    <div class=\"fullname\">\n      <input type=\"text\" formControlName=\"familyName\" placeholder=\"姓\" />\n      <input type=\"text\" formControlName=\"firstName\" placeholder=\"名\" />\n    </div>\n    <ng-container *ngIf=\"form?.errors?.emptyFullName\">\n      <div class=\"error-message\">氏名を入力指定ください</div>\n    </ng-container>\n    <ng-container *ngIf=\"form?.errors?.emptyFirstName\">\n      <div class=\"error-message\">名前（姓）を入力してください</div>\n    </ng-container>\n    <ng-container *ngIf=\"form?.errors?.emptyFamilyName\">\n      <div class=\"error-message\">名前（名）を入力してください</div>\n    </ng-container>\n\n    <div class=\"username\">\n      <input type=\"text\" formControlName=\"userName\" placeholder=\"ユーザー名\" />\n    </div>\n    <ng-container *ngIf=\"userName?.errors?.required\">\n      <div class=\"error-message\">ユーザー名は必須です</div>\n    </ng-container>\n    <ng-container *ngIf=\"userName?.errors?.minlength || userName?.errors?.maxlength\">\n      <div class=\"error-message\">ユーザー名は 6 文字から 30 文字の間で設定する必要があります</div>\n    </ng-container>\n\n    <div class=\"password\">\n      <input type=\"password\" formControlName=\"password\" placeholder=\"パスワード\" />\n      <input type=\"password\" formControlName=\"passwordConfirmation\" placeholder=\"確認\" />\n    </div>\n    <ng-container *ngIf=\"password?.errors?.required\">\n      <div class=\"error-message\">パスワードを入力</div>\n    </ng-container>\n    <ng-container *ngIf=\"password?.errors?.minlength\">\n      <div class=\"error-message\">パスワードは 8 文字以上で設定してください</div>\n    </ng-container>\n    <ng-container *ngIf=\"form.errors?.unmatchPassword\">\n      <div class=\"error-message\">パスワードが一致しませんでした</div>\n    </ng-container>\n\n    <div class=\"action\">\n      <button type=\"submit\" class=\"submit-button\" (click)=\"onSubmit()\">次へ</button>\n    </div>\n  </form>\n</div>\n","import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\nimport { AbstractControl, FormBuilder, FormGroup, ValidationErrors, ValidatorFn, Validators } from '@angular/forms';\n\n// tslint:disable-next-line:cyclomatic-complexity\nconst fullNameValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n  const firstName = control.get('firstName');\n  const familyName = control.get('familyName');\n\n  if (firstName?.value === '' && familyName?.value === '') {\n    return { emptyFullName: true };\n  }\n\n  if (firstName?.value === '') {\n    return { emptyFirstName: true };\n  }\n\n  if (familyName?.value === '') {\n    return { emptyFamilyName: true };\n  }\n\n  return null;\n};\n\n// tslint:disable-next-line:cyclomatic-complexity\nconst passwordConfirmationValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n  const password = control.get('password');\n  const passwordConfirmation = control.get('passwordConfirmation');\n\n  if (password === null || passwordConfirmation === null) {\n    return null;\n  }\n\n  return password.errors !== null || password.value === passwordConfirmation.value ? null : { unmatchPassword: true };\n};\n@Component({\n  selector: 'app-signup-form',\n  templateUrl: './signup-form.component.html',\n  styleUrls: ['./signup-form.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SignupFormComponent implements OnInit {\n  constructor(private readonly fb: FormBuilder) {}\n  form: FormGroup = this.fb.group(\n    {\n      firstName: ['', Validators.required],\n      familyName: ['', Validators.required],\n      userName: ['', [Validators.required, Validators.minLength(6), Validators.maxLength(30)]],\n      password: ['', [Validators.required, Validators.minLength(8)]],\n      passwordConfirmation: [''],\n    },\n    { validators: [fullNameValidator, passwordConfirmationValidator] },\n  );\n\n  get userName() {\n    return this.form.get('userName');\n  }\n\n  get password() {\n    return this.form.get('password');\n  }\n\n  ngOnInit(): void {}\n\n  onSubmit(): void {\n    if (this.form.valid) {\n      // tslint:disable-next-line:no-console\n      console.log(this.form.value);\n      return;\n    }\n    // tslint:disable-next-line:no-console\n    console.log('this form is invalid. this.form.invalid = ', this.form.invalid);\n  }\n}\n","import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-signup',\n  templateUrl: './signup.component.html',\n  styleUrls: ['./signup.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SignupComponent implements OnInit {\n  constructor() {}\n\n  ngOnInit(): void {}\n}\n","<app-signup-form></app-signup-form>\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { SignupPageComponent } from './pages/signup/signup.component';\n\nconst routes: Routes = [{ path: '', component: SignupPageComponent, pathMatch: 'full' }];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class SignupRoutingModule {}\n","import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\n\n@Component({\n  template: `<app-signup></app-signup>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SignupPageComponent implements OnInit {\n  constructor() {}\n\n  ngOnInit(): void {}\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { SignupFormComponent } from './components/signup-form/signup-form.component';\nimport { SignupComponent } from './containers/signup/signup.component';\nimport { SignupPageComponent } from './pages/signup/signup.component';\nimport { SignupRoutingModule } from './signup-routing.module';\n\n@NgModule({\n  declarations: [SignupPageComponent, SignupComponent, SignupFormComponent],\n  imports: [CommonModule, ReactiveFormsModule, SignupRoutingModule],\n})\nexport class SignupModule {}\n"],"sourceRoot":"webpack:///"}